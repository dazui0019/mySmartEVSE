# 充电桩功能实现

## 延时上(断)电功能

使用一个结构体来保存

```c
struct DelayedTimeStruct {
    uint32_t epoch2;    // 表示延时上电(断)开启的时间,
                        // 如果该变量为0则表示不在延时上电模式
    int32_t diff;       // 开始时间减去当前时间(单位s)
                        // 当diff <= 0时表示延时结束, 开始上电 
};
#define EPOCH2_OFFSET 1672531200    // 2023/1/1的时间戳
// epoch2 使用的时间戳是从2023/1/1开始的

// 计算延时上电的剩余时间
DelayedStartTime.diff = DelayedStartTime.epoch2 - (mktime(localtime(&now)) - EPOCH2_OFFSET);

// 这个用来标记本地时间是否完成同步(同步完成后才能开启延时上电模式)
bool LocalTimeSet = false;
```
### 固件自动更新功能

1. 随机生成一个时间(>10h)
2. 将这个时间倒计时到只剩1h后, 检查是否有固件升级。
3. 如果需要升级, 则继续倒计时, 直到剩余时间为0执行实际的更新操作。
4. 如果不需要更新, 则重新生成一个>10h的时间, 进入下一个固件更新检测循环。

这个随机时可能的作用：
- 设备不会同时检查更新，避免服务器负载峰值
- 确认更新后有延迟（1小时）再执行，避免立即更新可能带来的问题
- 更新检查间隔至少为10小时，避免频繁检查

## Timer10ms_loop()

### 背光控制逻辑

这里有两个变量, 用来控制背光状态:
- `BacklightTimer`: 用来控制背光开启的时间(单位: 秒)
  - 这个变量一秒钟递减一次
- `BacklightSet`: 背光状态
   - `BacklightSet == 1`表示背光全开
   - `BacklightSet == 2`表示背光进入渐灭状态
   - `BacklightSet == 0`表示背光关闭

### 按键采样

~~由于有两个按键引脚共用LCD的SPI通信引脚, 所以需要确保在读取按键的同时SPI没有被使用, 所以在按键检测的函数中还包含了LCD刷新功能。~~

```c
    pinMatrixOutDetach(PIN_LCD_SDO_B3, false, false);       // disconnect MOSI pin
    pinMode(PIN_LCD_SDO_B3, INPUT);
    pinMode(PIN_LCD_A0_B2, INPUT);  // LCD_A0在LCD上本来就是作为GPIO使用, 所以直接改成输入即可

    // sample buttons                                                         < o >
    ButtonState = (digitalRead(PIN_LCD_SDO_B3) ? 4 : 0) |  // > (right)
                    (digitalRead(PIN_LCD_A0_B2)  ? 2 : 0) |  // o (middle)
                    (digitalRead(PIN_IO0_B1)     ? 1 : 0);   // < (left)
    // 这个 4、2、1 就是 1<<2、1<<1、1<<0 三个位, 
    // 然后上面会把这三个位组合起来(也就是可以检测到三个按键同时按下的情况)
    // 通过原理图可知, 当按键按下时值为0

    pinMode(PIN_LCD_SDO_B3, OUTPUT);
    pinMatrixOutAttach(PIN_LCD_SDO_B3, VSPID_IN_IDX, false, false); // re-attach MOSI pin
    pinMode(PIN_LCD_A0_B2, OUTPUT);                        // switch pin back to output
```

这里还要适配网页上的虚拟按键
```c
    // ButtonStateOverride: 网页按键状态, 该变量不等于7时表示有按键被按下。
    // LastBtnOverrideTime < 4000, 表示当上一次的网页按键状态更新距离现在小于4s
    // 满足上面两种情况则将网页按键状态更新到按键状态变量中。
    if (ButtonStateOverride != 7 && millis() - LastBtnOverrideTime < 4000)
        ButtonState = ButtonStateOverride;
    else {
        // 物理按键检测
    }
```

### 按键菜单联动

当有按键按下时, 将按键状态传递给菜单处理函数.
```c
    // When one or more button(s) are pressed, we call GLCDMenu
    if (((ButtonState != 0x07) || (ButtonState != OldButtonState)) ) {
        // RCM was tripped, but RCM level is back to normal
        if (getItemValue(MENU_RCMON) == 1 && (ErrorFlags & RCM_TRIPPED) && RCMFAULT == LOW) {
            clearErrorFlags(RCM_TRIPPED);         // Clear RCM error bit
        }
        if (!LCDlock) GLCDMenu(ButtonState);    // LCD is unlocked, enter menu
    }
```

该产品设计成RCM_FAULT可以通过按键手动清除, 因此该函数中有RCM部分的代码。

```c
    // 按下按键后, 清除RCM故障
    if (getItemValue(MENU_RCMON) == 1 && (ErrorFlags & RCM_TRIPPED) && RCMFAULT == LOW) {
        clearErrorFlags(RCM_TRIPPED);         // Clear RCM error bit
    }
```

### 菜单函数

1. 进入菜单
    ```c
    if ((LCDNav == 0) && (Buttons == 0x5) && (ButtonRelease == 0)) {
        // 按键中间按键后, 准备进入菜单
        LCDNav = MENU_ENTER;
        ButtonTimer = millis();
    } else if (LCDNav == MENU_ENTER && ((ButtonTimer + 2000) < millis() )) {
        // 长按按键2s, 进入菜单
        LCDNav= MenuItems[0];
        ButtonRelease = 1;
    } else if ((LCDNav == MENU_ENTER) && (Buttons == 0x7)) {
        // 松开所有按键: 退出菜单(或者取消进入菜单)
        LCDNav = 0;
        ButtonRelease = 0;
        GLCD();
    }
    ```
2. 关闭充电
    ```c
    else if ((LCDNav == 0) && (Buttons == 0x6) && (ButtonRelease == 0)) {
        // 按下左边按键后, 准备进入关闭充电的逻辑
        LCDNav = MENU_OFF;
        ButtonTimer = millis();
    } else if (LCDNav == MENU_OFF && ((ButtonTimer + 2000) < millis() )) {
        // 长按左边按键2s, 关闭充电
        LCDNav = 0;
        setAccess(OFF);
        ButtonRelease = 1;
    } else if ((LCDNav == MENU_OFF) && (Buttons == 0x7)) {
        // 按下后在2s内抬起, 则切换模式(在Solar 和 Smart模式之间切换)
        // 如果是Normal模式就保持不变(if判断不成立)
        if (Mode)
            setMode(~Mode & 0x3);
        LCDNav = 0;
        ButtonRelease = 0;
        GLCD();
    }
    ```
3. 开启充电
    ```c
    else if ((AccessStatus == OFF) && (LCDNav == 0) && (Buttons == 0x3) && (ButtonRelease == 0)) {
        // 按键右边按键, 准备进入开启充电的逻辑
        LCDNav = MENU_ON;
        ButtonTimer = millis();
    } else if (LCDNav == MENU_ON && ((ButtonTimer + 2000) < millis() )) {
        // 长按2s开启充电
        LCDNav = 0;
        setAccess(ON);
        ButtonRelease = 1;
    } else if ((LCDNav == MENU_ON) && (Buttons == 0x7)) {
        // 2s内松开按键, 返回空闲状态
        LCDNav = 0;
        ButtonRelease = 0;
        GLCD();
    }
    ```
4. 重置LCD
    ```c
    // 同时按下左边按键和右边按键
    else if (Buttons == 0x2 && (ButtonRelease < 2)) {
        if (LCDNav == 0) GLCD_init();   // 如果没有进入LCD菜单(在菜单中同时按下的操作会作为正常操作), 则重新初始化LCD驱动
        ButtonRelease = 1;
        // 进入该语句块并退出之后, 会在GLCDMenu()函数的末尾进行LCD更新
        //更新完成之后, ButtonRelease会被赋值成2, 所以下一次执行GLCDMenu()函数时, 就不会在进入该语句块了
    }
    ```
5. 