# 充电桩功能实现

## 延时上(断)电功能

使用一个结构体来保存

```c
struct DelayedTimeStruct {
    uint32_t epoch2;    // 表示延时上电(断)开启的时间,
                        // 如果该变量为0则表示不在延时上电模式
    int32_t diff;       // 开始时间减去当前时间(单位s)
                        // 当diff <= 0时表示延时结束, 开始上电 
};
#define EPOCH2_OFFSET 1672531200    // 2023/1/1的时间戳
// epoch2 使用的时间戳是从2023/1/1开始的

// 计算延时上电的剩余时间
DelayedStartTime.diff = DelayedStartTime.epoch2 - (mktime(localtime(&now)) - EPOCH2_OFFSET);

// 这个用来标记本地时间是否完成同步(同步完成后才能开启延时上电模式)
bool LocalTimeSet = false;
```
### 固件自动更新功能

1. 随机生成一个时间(>10h)
2. 将这个时间倒计时到只剩1h后, 检查是否有固件升级。
3. 如果需要升级, 则继续倒计时, 直到剩余时间为0执行实际的更新操作。
4. 如果不需要更新, 则重新生成一个>10h的时间, 进入下一个固件更新检测循环。

这个随机时可能的作用：
- 设备不会同时检查更新，避免服务器负载峰值
- 确认更新后有延迟（1小时）再执行，避免立即更新可能带来的问题
- 更新检查间隔至少为10小时，避免频繁检查

## Timer10ms_loop()

### 背光控制逻辑

这里有两个变量, 用来控制背光状态:
- `BacklightTimer`: 用来控制背光开启的时间(单位: 秒)
  - 这个变量一秒钟递减一次
- `BacklightSet`: 背光状态
   - `BacklightSet == 1`表示背光全开
   - `BacklightSet == 2`表示背光进入渐灭状态
   - `BacklightSet == 0`表示背光关闭

### 按键采样

~~由于有两个按键引脚共用LCD的SPI通信引脚, 所以需要确保在读取按键的同时SPI没有被使用, 所以在按键检测的函数中还包含了LCD刷新功能。~~

```c
    pinMatrixOutDetach(PIN_LCD_SDO_B3, false, false);       // disconnect MOSI pin
    pinMode(PIN_LCD_SDO_B3, INPUT);
    pinMode(PIN_LCD_A0_B2, INPUT);  // LCD_A0在LCD上本来就是作为GPIO使用, 所以直接改成输入即可

    // sample buttons                                                         < o >
    ButtonState = (digitalRead(PIN_LCD_SDO_B3) ? 4 : 0) |  // > (right)
                    (digitalRead(PIN_LCD_A0_B2)  ? 2 : 0) |  // o (middle)
                    (digitalRead(PIN_IO0_B1)     ? 1 : 0);   // < (left)
    // 这个 4、2、1 就是 1<<2、1<<1、1<<0 三个位, 
    // 然后上面会把这三个位组合起来(也就是可以检测到三个按键同时按下的情况)
    // 通过原理图可知, 当按键按下时值为0

    pinMode(PIN_LCD_SDO_B3, OUTPUT);
    pinMatrixOutAttach(PIN_LCD_SDO_B3, VSPID_IN_IDX, false, false); // re-attach MOSI pin
    pinMode(PIN_LCD_A0_B2, OUTPUT);                        // switch pin back to output
```

这里还要适配网页上的虚拟按键
```c
    // ButtonStateOverride: 网页按键状态, 该变量不等于7时表示有按键被按下。
    // LastBtnOverrideTime < 4000, 表示当上一次的网页按键状态更新距离现在小于4s
    // 满足上面两种情况则将网页按键状态更新到按键状态变量中。
    if (ButtonStateOverride != 7 && millis() - LastBtnOverrideTime < 4000)
        ButtonState = ButtonStateOverride;
    else {
        // 物理按键检测
    }
```

### 按键菜单联动

当有按键按下时, 将按键状态传递给菜单处理函数.
```c
    // When one or more button(s) are pressed, we call GLCDMenu
    if (((ButtonState != 0x07) || (ButtonState != OldButtonState)) ) {
        // RCM was tripped, but RCM level is back to normal
        if (getItemValue(MENU_RCMON) == 1 && (ErrorFlags & RCM_TRIPPED) && RCMFAULT == LOW) {
            clearErrorFlags(RCM_TRIPPED);         // Clear RCM error bit
        }
        if (!LCDlock) GLCDMenu(ButtonState);    // LCD is unlocked, enter menu
    }
```

该产品设计成RCM_FAULT可以通过按键手动清除, 因此该函数中有RCM部分的代码。

```c
    // 按下按键后, 清除RCM故障
    if (getItemValue(MENU_RCMON) == 1 && (ErrorFlags & RCM_TRIPPED) && RCMFAULT == LOW) {
        clearErrorFlags(RCM_TRIPPED);         // Clear RCM error bit
    }
```

### 菜单函数

1. 进入菜单
    ```c
    if ((LCDNav == 0) && (Buttons == 0x5) && (ButtonRelease == 0)) {
        // 按键中间按键后, 准备进入菜单
        LCDNav = MENU_ENTER;
        ButtonTimer = millis();
    } else if (LCDNav == MENU_ENTER && ((ButtonTimer + 2000) < millis() )) {
        // 长按按键2s, 进入菜单
        LCDNav= MenuItems[0];
        ButtonRelease = 1;
    } else if ((LCDNav == MENU_ENTER) && (Buttons == 0x7)) {
        // 松开所有按键: 退出菜单(或者取消进入菜单)
        LCDNav = 0;
        ButtonRelease = 0;
        GLCD();
    }
    ```
2. 关闭充电
    ```c
    else if ((LCDNav == 0) && (Buttons == 0x6) && (ButtonRelease == 0)) {
        // 按下左边按键后, 准备进入关闭充电的逻辑
        LCDNav = MENU_OFF;
        ButtonTimer = millis();
    } else if (LCDNav == MENU_OFF && ((ButtonTimer + 2000) < millis() )) {
        // 长按左边按键2s, 关闭充电
        LCDNav = 0;
        setAccess(OFF);
        ButtonRelease = 1;
    } else if ((LCDNav == MENU_OFF) && (Buttons == 0x7)) {
        // 按下后在2s内抬起, 则切换模式(在Solar 和 Smart模式之间切换)
        // 如果是Normal模式就保持不变(if判断不成立)
        if (Mode)
            setMode(~Mode & 0x3);
        LCDNav = 0;
        ButtonRelease = 0;
        GLCD();
    }
    ```
3. 开启充电
    ```c
    else if ((AccessStatus == OFF) && (LCDNav == 0) && (Buttons == 0x3) && (ButtonRelease == 0)) {
        // 按键右边按键, 准备进入开启充电的逻辑
        LCDNav = MENU_ON;
        ButtonTimer = millis();
    } else if (LCDNav == MENU_ON && ((ButtonTimer + 2000) < millis() )) {
        // 长按2s开启充电
        LCDNav = 0;
        setAccess(ON);
        ButtonRelease = 1;
    } else if ((LCDNav == MENU_ON) && (Buttons == 0x7)) {
        // 2s内松开按键, 返回空闲状态
        LCDNav = 0;
        ButtonRelease = 0;
        GLCD();
    }
    ```
4. 重置LCD
    ```c
    // 同时按下左边按键和右边按键
    else if (Buttons == 0x2 && (ButtonRelease < 2)) {
        if (LCDNav == 0) GLCD_init();   // 如果没有进入LCD菜单(在菜单中同时按下的操作会作为正常操作), 则重新初始化LCD驱动
        ButtonRelease = 1;
        // 进入该语句块并退出之后, 会在GLCDMenu()函数的末尾进行LCD更新
        //更新完成之后, ButtonRelease会被赋值成2, 所以下一次执行GLCDMenu()函数时, 就不会在进入该语句块了
    }
    ```
5. 按键长按
    ```c
    // 长按按键0.5s后, 重复触发事件
    else if (ButtonRelease == 2 && ButtonRepeat == 0) {
        ButtonRepeat = 500;
        ButtonTimer = millis() + ButtonRepeat;  // 设置触发时间
    } else if (ButtonRepeat && millis() > ButtonTimer) {
        // 当ButtonRepeat被设置且时间大于触发时间后将ButtonRelease置0, 允许按键输入
        ButtonRelease = 0;
        if (ButtonRepeat > 1) {
            ButtonRepeat -= (ButtonRepeat / 8); // ButtonRepeat逐渐减少
            ButtonTimer = millis() + ButtonRepeat;  // 更新下一次触发的时间
        }
    }
    // 这里可以看到ButtonRepeat是逐渐减少, 所以按键重复的速率也会加快
    ```
## CP部分

### CP电压判断

在电压缓冲区里面找出最大值和最小值, 然后根据最大值和最小值来判断CP状态。

```c
// test Min/Max against fixed levels
if (Min >= 3055 ) return PILOT_12V;
if ((Min >= 2735) && (Max < 3055)) return PILOT_9V;
if ((Min >= 2400) && (Max < 2735)) return PILOT_6V;
if ((Min >= 2000) && (Max < 2400)) return PILOT_3V;
if ((Min > 100) && (Max < 300)) return PILOT_DIODE;
return PILOT_NOK;
```

### 车端二极管检测

SmartEVSE在进入`STATE_B`状态时, 会将CP采样的位置设置在CP信号的低电平上面(`PWM_95`), 采样到的电压如果在`100mV-300mV`之间则代表二极管存在, 可以充电。
> 就是采样CP低电平电压。

```c
if ((Min > 100) && (Max < 300)) return PILOT_DIODE;
``` 

### CP状态处理

不同CP状态下的处理:
1. `STATE_A`: 未插枪状态。
2. `STATE_B`: 已插枪、未刷卡。
3. `STATE_C`: 已插枪、已刷卡输出PWM, 汽车闭合S2(不需要通风`CP_6V`)。 在从`STATE_B`切换到`STATE_C`之前需要确保CP电压在6V的位置保持500ms以上。
4. `STATE_D`: 已插枪、已刷卡输出PWM, 汽车闭合S2(需要通风`CP_3V`)。
5. `STATE_COMM_B`: 已插枪(但充电桩作为DLB的节点时, 先进入`COMM_B`状态, 检查是否有剩余可用的电流)。
6. `STATE_COMM_B_OK`: 进入`COMM_B`状态后, 检查是否有剩余可用电流, 如果有的话就设置为`COMM_B_OK`状态。
7. `STATE_COMM_C`: 类似`STATE_COMM_B`
8. `STATE_COMM_C_OK`: 类似`STATE_COMM_B_OK`
9. `STATE_ACTSTART`: 当插枪后一定时间内(30s)汽车没有闭合S2, 一般是电流设置与汽车不匹配(占空比不正确), 则EVSE进入该状态关闭PWM输出然后重新进入`STATE_B`(调整电流后, 重新输出PWM信号)。
10. `STATE_B1`: 已插枪且汽车断开S2, EVSE不输出PWM。
11. `STATE_C1`: 已插枪且汽车闭合S2, 但EVSE不输出PWM(例如用户暂停充电, 或EVSE主动暂停输出)。

#### STATE_A

1. 模拟开关: 电路上有一个模拟开关, 断开一定时间后需要重连

    ```c
    // 当PilotDisconnectTime == 0时, 重新连接CP
    if (PilotDisconnectTime == 0 && pilot == PILOT_NOK ) {
        PILOT_CONNECTED;    // 闭合模拟开关
        PilotDisconnected = false;
        _LOG_A("Pilot Connected\n");
    }
    ```

2. CP_12V

    ```c
    if (pilot == PILOT_12V) {
        // 这个if语句的作用应该是在未插枪的状态下, 如果刷卡认证的60s内没有插枪的话, 就自动锁定(取消认证)
        if ((RFIDReader == 2 || RFIDReader == 1) && AccessTimer == 0 && AccessStatus == ON)
            AccessTimer = RFIDLOCKTIME;

        if (State != STATE_A) setState(STATE_A);
        setChargeDelay(0);  // 未插枪状态下清除延时上电时间
        if (!EVMeter.ResetKwh) EVMeter.ResetKwh = 1;    // 重置电量
    }
    ```
3. CP_9V

    ```c
    if ( pilot == PILOT_9V && ErrorFlags == NO_ERROR
        && ChargeDelay == 0 && AccessStatus == ON && State != STATE_COMM_B ){
        DiodeCheck = 0;
        // 获取枪线最大电流容量
        MaxCapacity = ProximityPin();

        _LOG_I("Cable limit: %uA  Max: %uA\n", MaxCapacity, MaxCurrent);
        if (MaxCurrent > MaxCapacity) ChargeCurrent = MaxCapacity * 10;
        else ChargeCurrent = MinCurrent * 10;

        if (LoadBl > 1) {   // LoadBl > 1表示该EVSE是DLB的节点
            // DLB节点需要检查剩余可用电流(至少需要6A), 如果有可用的电流才会提供充电服务(输出PWM)
            // 节点的电流由DLB主机, 通过Modbus配置
            setState(STATE_COMM_B);
        } else if (IsCurrentAvailable()) { // LoadBl < 1表示DLB禁用或者设备为DLB主机
            // 如果有足够的电流, 则切换到STATE_B
            BalancedMax[0] = MaxCapacity * 10;
            Balanced[0] = ChargeCurrent;
                setState(STATE_B);
            ActivationMode = 30;
            AccessTimer = 0;
        } else setErrorFlags(LESS_6A);
    } else if (pilot == PILOT_9V && State != STATE_B1 && State != STATE_COMM_B && AccessStatus == ON) {
        // 如果需要等待延时上电或者发生故障, 则先进入STATE_B1
        setState(STATE_B1);
    }
    ```
#### STATE_COMM_B

在`STATE_COMM_B`状态下, 如果有足够的剩余电流, 则会被(modbus任务)切换到`STATE_COMM_B_OK`。

```c
if (State == STATE_COMM_B_OK) {
    setState(STATE_B);
    ActivationMode = 30;
    AccessTimer = 0;
}
```

#### STATE_B

1. PILOT_12V

    ```c
    if (pilot == PILOT_12V) {
        // 断开与汽车的连接
        setState(STATE_A);
    }
    ```
2. PILOT_9V

    ```c
    if (pilot == PILOT_9V) {
        StateTimer = 0; // 这个计数器用来, 给CP_6V计时, 当CP_6V维持500ms以上时, EVSE将从STATE_B 切换到 STATE_C
        if (ActivationMode == 0) {
            // 先介绍一下ActivationMode:
            // 当EVSE进入STATE_B后的一定时间以内(默认是30S), 如果汽车没有闭合S2(没有进入CP_6V)
            // 则EVSE进入STATE_ACTSTART, 等待3S后重新进入STATE_B
            // 汽车长时间没有进入STATE_C主要是因为EVSE设置的电流不匹配(CP占空比), 因此需要重新进入STATE_B配置电流大小
            setState(STATE_ACTSTART);
            ActivationTimer = 3;    // 3s后退出STATE_ACTSTART, 进入STATE_B
            SetCPDuty(0);   // 关闭PWM, 修改电流后在STATE_B状态里重新开启
        }
    }
    ```

3. PILOT_6V
    
    ```c
    // pilot == PILOT_6V且保持500ms以上(StateTimer每10ms自增一次)
    if (pilot == PILOT_6V && ++StateTimer > 50) {
        if (DiodeCheck == 1 && ErrorFlags == NO_ERROR && ChargeDelay == 0 && AccessStatus == ON) {
            if (EVMeter.Type && EVMeter.ResetKwh) {
                EVMeter.EnergyMeterStart = EVMeter.Energy;
                EVMeter.EnergyCharged = EVMeter.Energy - EVMeter.EnergyMeterStart;
                EVMeter.ResetKwh = 0;
            }
            // 这里与STATE_COMM_B类似, 同样是为了支持DLB
            if (LoadBl > 1) {
                if (State != STATE_COMM_C) setState(STATE_COMM_C);
            } else {
                // todo: 深入了解一下DLB功能实现
                BalancedMax[0] = ChargeCurrent;
                if (IsCurrentAvailable()) {
                    Balanced[0] = 0;
                    CalcBalancedCurrent(1);
                    DiodeCheck = 0;
                    setState(STATE_C);
                    if (!LCDNav) _GLCD; // 进入STATE_C后立即更新UI, 显示充电状态
                } else setErrorFlags(LESS_6A);  // 剩余电流小于6A
            }
        }
    }
    ```
#### STATE_C1

1. PILOT_12V
    ```c
    if (pilot == PILOT_12V)
    {
        setState(STATE_A);
        // 切换到STATE_A会断开接触器, 然后断开接触器有几率导致LCD乱码
        // 所以在这里直接重新初始化一次LCD
        GLCD_init();
    }
    ```
2. PILOT_9V
    ```c
    else if (pilot == PILOT_9V)
    {
        setState(STATE_B1);
        GLCD_init();    // 跟上面一样
    }
    ```
#### STATE_ACTSTART

```c
if (State == STATE_ACTSTART && ActivationTimer == 0) {
    // 倒计时三秒结束后
    // 从 STATE_ACTSTART 进入 STATE_B
    setState(STATE_B);
    ActivationMode = 255;   // 关闭 ActivationMode(30秒S2闭合检测)
}
```

#### STATE_COMM_C_OK

```c
if (State == STATE_COMM_C_OK) {
    // 进入STATE_C时, 先将二极管检测标志复位
    // 后面进入STATE_C需要重新检测。
    DiodeCheck = 0;
    setState(STATE_C);
    // 似乎进入STATE_C后需要立即更新LCD
    // 如果在菜单页面, 则不更新LCD(防止页面冲突)
    if (!LCDNav) _GLCD;
}
```

#### STATE_C

1. PILOT_12V

    ```c
    if (pilot == PILOT_12V) {
        setState(STATE_A);
        GLCD_init();    // 断开接触器后重新初始化LCD
    }
    ```

2. PILOT_9V
    
    ```c
    else if (pilot == PILOT_9V) {
        setState(STATE_B);
        DiodeCheck = 0; // 清除Diode OK标志, 下次重新检测
        GLCD_init(); // 断开接触器后重新初始化LCD
    }
    ```
3. CP != PILOT_6V
    
    在`STATE_C`状态下, 如果CP电压不为`6V`则需要做出动作。
    ```c
    if (pilot != PILOT_6V) {
        if (++StateTimer > 50) {
            // 当CP电压不为6V, 且持续时间超过500ms(StateTimer每10ms自增一次)
            // 则切换回STATE_B
            StateTimer = 0;
            setState(STATE_B);
            DiodeCheck = 0; // 清除Diode OK标志(下次进入STATE_B需要重新检测)
            GLCD_init();    // 断开接触器需要重新初始化LCD
        }
    }
    ```
## RCD检测

```c
// RCmon: Residual Current Monitor (0:Disable / 1:Enable)
if (RCmon == 1 && digitalRead(PIN_RCM_FAULT) == HIGH) {
    delay(1);
    // 延迟1mS后再检测一次
    if (digitalRead(PIN_RCM_FAULT) == HIGH) {
        if (State) setState(STATE_B1);
        setErrorFlags(RCM_TRIPPED);
        LCDTimer = 0;   // todo: 不懂(应该跟LCD刷新有关), 看一下LCD刷新函数
    }
}
```

## LCD

### LCD刷新

```c
```
